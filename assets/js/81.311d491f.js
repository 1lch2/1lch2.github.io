(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{382:function(a,t,s){"use strict";s.r(t);var r=s(13),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"javascript基础-堆和栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript基础-堆和栈"}},[a._v("#")]),a._v(" JavaScript基础 - 堆和栈")]),a._v(" "),t("h2",{attrs:{id:"栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[a._v("#")]),a._v(" 栈")]),a._v(" "),t("p",[a._v("栈(stack)：是栈内存的简称，栈是自动分配相对固定大小的内存空间，并由系统自动释放。")]),a._v(" "),t("p",[a._v("栈内存具有速度快，容量小的特点。")]),a._v(" "),t("h3",{attrs:{id:"存储数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存储数据"}},[a._v("#")]),a._v(" 存储数据")]),a._v(" "),t("p",[a._v("基本类型的数据都是按值直接存放在栈内存中。")]),a._v(" "),t("p",[a._v("这样做的好处是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。")]),a._v(" "),t("h3",{attrs:{id:"内存分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[a._v("#")]),a._v(" 内存分配")]),a._v(" "),t("p",[a._v("线性有序存储，容量小，系统分配效率高。")]),a._v(" "),t("h2",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),t("p",[a._v("堆(heap)：是堆内存的简称，堆是动态分配内存，内存大小不固定，也不会自动释放，堆数据结构是一种无序的树状结构，同时它还满足key-value键值对的存储方式")]),a._v(" "),t("h3",{attrs:{id:"存储数据-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存储数据-2"}},[a._v("#")]),a._v(" 存储数据")]),a._v(" "),t("p",[a._v("引用类型的数据，通过拷贝或new操作符生成后，存放在堆内存中。")]),a._v(" "),t("h3",{attrs:{id:"内存分配-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分配-2"}},[a._v("#")]),a._v(" 内存分配")]),a._v(" "),t("p",[a._v("首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中")]),a._v(" "),t("p",[a._v("堆内存中的对象不会随方法的结束而销毁，就算方法结束了，这个对象也可能会被其他引用变量所引用(参数传递)。")])])}),[],!1,null,null,null);t.default=v.exports}}]);