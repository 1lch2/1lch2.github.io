(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{371:function(t,r,a){"use strict";a.r(r);var v=a(13),_=Object(v.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"javascript基础-遍历器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript基础-遍历器"}},[t._v("#")]),t._v(" JavaScript基础 - 遍历器")]),t._v(" "),r("h2",{attrs:{id:"iterator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#iterator"}},[t._v("#")]),t._v(" Iterator")]),t._v(" "),r("p",[r("code",[t._v("Iterator")]),t._v("是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。")]),t._v(" "),r("p",[t._v("Iterator 主要供 "),r("code",[t._v("for-of")]),t._v(" 循环消费，这是ES6新增的语法。")]),t._v(" "),r("h3",{attrs:{id:"具有接口的对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#具有接口的对象"}},[t._v("#")]),t._v(" 具有接口的对象")]),t._v(" "),r("p",[t._v("原生具备 Iterator 接口的数据结构如下。")]),t._v(" "),r("ul",[r("li",[t._v("String")]),t._v(" "),r("li",[t._v("Array")]),t._v(" "),r("li",[t._v("Map")]),t._v(" "),r("li",[t._v("Set")]),t._v(" "),r("li",[t._v("TypedArray")]),t._v(" "),r("li",[t._v("函数的 arguments 对象")]),t._v(" "),r("li",[t._v("NodeList 对象")])]),t._v(" "),r("h3",{attrs:{id:"遍历过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#遍历过程"}},[t._v("#")]),t._v(" 遍历过程")]),t._v(" "),r("p",[t._v("Iterator 的遍历过程是这样的。")]),t._v(" "),r("p",[t._v("（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。")]),t._v(" "),r("p",[t._v("（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。")]),t._v(" "),r("p",[t._v("（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。")]),t._v(" "),r("p",[t._v("（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。")]),t._v(" "),r("p",[t._v("每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。")])])}),[],!1,null,null,null);r.default=_.exports}}]);